import os
from fastapi import APIRouter, HTTPException, Request, Depends
from sqlalchemy.orm import Session
from cryptography.fernet import Fernet, InvalidToken

from ..db import get_db
from ..models_db import ConnectionProfile


router = APIRouter(prefix="/settings/profile", tags=["settings"])


def get_cipher() -> Fernet:
    key = os.environ.get("ENCRYPTION_KEY")
    if not key:
        raise HTTPException(500, "ENCRYPTION_KEY not configured")
    try:
        return Fernet(key)
    except Exception:
        raise HTTPException(500, "Invalid ENCRYPTION_KEY format. Use base64 32-byte key generated by Fernet.generate_key().")


@router.post("/save")
async def save_profile(request: Request, db: Session = Depends(get_db)):
    data = await request.json()
    name = data.get("name")
    if not name:
        raise HTTPException(400, "name is required")

    # Expect connection data in session
    connections = request.session.get("connections")
    if not connections or not ("source" in connections and "dest" in connections):
        raise HTTPException(400, "No active connections in session to save")

    cipher = get_cipher()
    s = connections["source"]
    d = connections["dest"]

    enc_spw = cipher.encrypt(s["password"].encode()).decode()
    enc_dpw = cipher.encrypt(d["password"].encode()).decode()

    existing = db.query(ConnectionProfile).filter(ConnectionProfile.name == name).first()
    if existing:
        existing.source_url = s["url"]
        existing.source_username = s["username"]
        existing.source_password_enc = enc_spw
        existing.dest_url = d["url"]
        existing.dest_username = d["username"]
        existing.dest_password_enc = enc_dpw
        db.add(existing)
        db.commit()
        db.refresh(existing)
        return {"id": existing.id, "updated": True}

    item = ConnectionProfile(
        name=name,
        source_url=s["url"],
        source_username=s["username"],
        source_password_enc=enc_spw,
        dest_url=d["url"],
        dest_username=d["username"],
        dest_password_enc=enc_dpw,
    )
    db.add(item)
    db.commit()
    db.refresh(item)
    return {"id": item.id, "created": True}


@router.get("/list")
async def list_profiles(db: Session = Depends(get_db)):
    items = db.query(ConnectionProfile).order_by(ConnectionProfile.created_at.desc()).all()
    return [
        {
            "id": i.id,
            "name": i.name,
            "source_url": i.source_url,
            "dest_url": i.dest_url,
            "created_at": i.created_at.isoformat(),
        }
        for i in items
    ]


@router.get("/{profile_id}")
async def load_profile(profile_id: str, request: Request, db: Session = Depends(get_db)):
    item = db.query(ConnectionProfile).filter(ConnectionProfile.id == profile_id).first()
    if not item:
        raise HTTPException(404, "Profile not found")
    cipher = get_cipher()
    try:
        spw = cipher.decrypt(item.source_password_enc.encode()).decode()
        dpw = cipher.decrypt(item.dest_password_enc.encode()).decode()
    except InvalidToken:
        raise HTTPException(500, "Failed to decrypt stored credentials")

    # Store only profile_id in session; resolve server-side when needed
    request.session["profile_id"] = item.id
    return {"loaded": True, "name": item.name, "profile_id": item.id}


@router.delete("/{profile_id}")
async def delete_profile(profile_id: str, db: Session = Depends(get_db)):
    item = db.query(ConnectionProfile).filter(ConnectionProfile.id == profile_id).first()
    if not item:
        raise HTTPException(404, "Profile not found")
    db.delete(item)
    db.commit()
    return {"deleted": True}


